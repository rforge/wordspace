# -*-org-*-
#+TITLE: TODO sheet for wordspace package development
#+AUTHOR: Stefan Evert
#+EMAIL:  stefan.evert@fau.de
#+LANGUAGE:  en
#+OPTIONS:   H:3 num:t toc:nil \n:nil @:t ::t |:t ^:t -:t f:t *:t <:t
#+OPTIONS:   TeX:t LaTeX:t skip:nil d:nil todo:t pri:nil tags:not-in-toc
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="etc/orgmode.css" />

* Urgent updates for COLING paper submission

  - (optional) implement "network" plot as =plot.dist.matrix()= method
  - implement =head.dsm()= method: =head(M, n)= shows first $n$ rows and columns; =head(M, n, k)= shows first $n$ rows and $k$ columns; automatically selects =$S= (if available) or =$M=
  - implement =print.dsm()= method, which just displays information from =check.dsm()= in a user-friendly form
    - perhaps with option to show details about row/column data etc., or implement =summary.dsm()= for this purpose
  - special case optimization in =subset.dsm()=: return input unchanged if no rows or columns are dropped (to avoid unnecessary duplication with recursive=TRUE)
  - =write.dsm.matrix()= as safe wrapper around =write()= for very large output files
    - can't be called =write.matrix()=, which already exists in MASS (but doesn't look very optimal)
    - should have options to save row/column names and dense/sparse matrices in various text formats
  - basic documentation and usage examples for all functions
  - =nearest.neighbours()= should optionally return =dist.matrix= of target term and its nearest neighbours
    - index of target term in matrix annotated as =attr("selected")=
  - method =plot.dist.matrix()= for visualization of semantic maps
    - options to show/hide labels, choice of MDS methods
    - option to show "spiderweb" plot of semantic neighbourhood; points indicated by =attr("selected")= are highlighted automatically
    - possible extension: class of points indicated by colour + legend box (for semantic maps); overrides highlighting(?)
    - returns MDS coordinates with terms as =rowlabels()=
  - interface to sparse SVD using SVDLIBC
    - as separate R package =sparseSVD= or so, required by =wordspace=

* Internal redesign

  - =rbind.dsm()= and =merge.dsm()= need to be updated and documented properly

* Combining DSM objects
  - implement =cbind.dsm()=
  - implement =all=TRUE= option for =merge.dsm()= ("expanding merge")
  - implement column merge (=rows=FALSE=) for =merge.dsm()=
  - efficient reimplementation of =rbind.dsm()= for sparse matrices (require all arguments to be sparse in normal form; use C code, work with triplet representation, or very clever code on =dgCMatrix= objects)

* Non-negative matrices and projections

  - Matrizen werden mit Attribut =non.negative= versehen; Frequenzmatrix M muss nonneg sein (wird von Konstruktor überprüft); S wird überprüft und entsprechend markiert
  - diverse Funktionen wie =dsm.score()=, =dsm.projection()=, =dist.matrix()=, ...  erlauben bestimmte Optionen / Algorithmen nur für nonneg-Matrizen; diese werden am Attribut =non.negative= erkannt; wenn Attribut fehlt, wird die Eingabematrix geprüft; evtl. expliziter Override mit =non.negative=TRUE= (aber sinnvoll?)
  - dafür C-Funktion, um Vektor/Matrix speichereffizient auf nonneg zu testen; in Methode =is.nonnegative()= einbinden, mit Methoden für numeric, matrix, und Matrix (csr oder triplet)
  - Ausgabe von dsm.projection mit NMF oder anderem nonneg-Algorithmus wird ebenfalls mit Attribut =non.negative=TRUE= markiert

* Support for evaluation experiments

  - =as.dist.matrix(M, sim=FALSE)= to mark as distance matrix (so =nearest.neighbours=, =pair.distances=, etc. can be used)
    - methods for dense and sparse canonical matrix (perhaps as =as.dist.matrix.default=)
    - method for =dist= objects, which converts them to full symmetric matrix
  - =nearest.neighbours()= and =pair.distances()= should work with M2 (= M) for cross-distance computations
    - don't exclude $d(x,y) = 0$ in =nearest.neighbours()=, which may be valid in certain spaces (and certainly in the cross-distance setting)
    - instead, exclude term as its own nearest neighbour if =M2=NULL=, but apply no other filters
    - in =pair.distances()=, adjust ranks by one only if =M2=NULL=
  - =pair.distances()= should accept pre-computed =dist.matrix= (both distance and similarity scores, marked appropriately)
    - may be difficult to integrate with implementation of cross-distances (and a more efficient implementation of average rank)
    - can be used to safely read out association scores from "fake" distance matrix (marked with =as.dist.matrix=)
  - also see hand-written notes

* Additional metrics
  - Dice and/or Jaccard coefficient (Lin 1998) –-> is there a meaningful formulation for non-negative vectors?
  - KL divergence and Jensen-Shannon metric (Endres & Schindelin 2003) for non-negative vectors
    - input matrices have to be checked unless they're already marked
    - KL divergence --> skew divergence (Lee 2001)?

* New projection methods

  - power scaling for =dsm.projection= (Caron 2001); needs built-in renormalization, I think, or keep total $R^2$ same
  - what is a sensible relative $R^2$ for different =dsm.projection= methods? especially SVD without centering and non-orthogonal projections
  - implement =nndsvd()= according to Boutsidis & Gallopoulos (2008)
    - transforms given SVD into an approximate non-negative decomposition
    - can this be interpreted as a (non-orthogonal) projection? what are the basis vectors?
    - what is a sensible $R^2$ in this case?
    - requires thorough validation test to determine approximation quality and usefulness of this decomposition
  - =dsm.projection()= could have an Option =non.negative=TRUE=
    - only valid if input matrix is non-negative
    - guarantees that projection is also non-negative (by using a non-negative basis with RI, and NNDSVD with SVD)
  - implement NMF (multiplicative updates, cf. Python code)
    - key element: C/C++ function to compute =crossprod()= only for nonzero entries of a given sparse matrix
    - possibly modified version of this function in order to compute approximation error of sparse matrix decomposition
    - NMF can be initialized with =nndsvd()= or NNDSVDar (but only reproducible if the initialization is not obtained by rSVD)
    - alternatively, carry out multiple runs with random initializations and select the best approximation
    - should also experiment with more sophisticated variants of NMF that include regularization terms (--> similar to sparse priors)
  - experiment with LDA and similar topic models
    - use implementation in =topicmodels= package
    - can this deal with arbitrary non-negative scores, or only (binary?) frequency counts?
    - can this still be interpreted as a projection method, or do we need a second function =dsm.decomp()=?

* Analysis support
  - implement Chinese Whispers clustering algorithm
    - try different versions: batch update with R code, single updates implemented in C/C++

* Cleanup and documentation

  - write complete (rough) documentation for basic functions
  - include more small data sets for usage examples
  - add usage examples to all functions

* Optimization

  - investigate memory overhead shown by benchmarks
    - cosine distance for dense (and possibly also sparse) matrix; very substantial overhead in "SVD-100 cosine distances" benchmark
    - dense dist.matrix() compared to dist()
  - =dsm.projection()= could have option =renormalized= that performs row normalization in-place (with additional arguments passed on to rowNorms())
  - implement optimized file I/O functions in Rcpp
    - https://github.com/romainfrancois/fastread shows how to use connections from Rcpp
    - e.g. two-pass =read.dsm.triplet()=, memory-friendly =write.matrix()=, etc.
    - perhaps I/O code for (co-occurrence) frequency tables and other forms of corpus data should be part of a separate package

* Miscellaneous

  - =print()= and =summary()= methods for =dsm= objects?
  - =normalize=TRUE= in =dsm.score()= might automatically filter out invalid rows (with $\|x\| = 0$) or keep them at 0 (rather than =NA=)
  - do we need to apply =normalizePath()= to input/output filenames?
  - new methods for =as.dsm()=
    - possibly also convenience methods for =matrix= and =dgCMatrix=, which would just be thin wrappers around =dsm()=
